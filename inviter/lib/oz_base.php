<?php
/********************************************************************************
DO NOT EDIT THIS FILE!

Base class and utilities

You may not reprint or redistribute this code without permission from Octazen Solutions.

Copyright 2009 Octazen Solutions. All Rights Reserved
WWW: http://www.octazen.com
********************************************************************************/
//Import settings from config file if present
//if (!defined('_ABI_CONFIG_FILE') && file_exists("abiconfig.php")) include("abiconfig.php");
//else if (!defined('_ABI_CONFIG_FILE') && file_exists("abimporter/abiconfig.php")) include("abimporter/abiconfig.php");

define('__ABI_CORE',1);



function oz_is_php5() {
	static $php5;
	if (!isset($php5)) $php5 = version_compare(phpversion(),"5.0.0",">=");
	return $php5;
}

//In Caucho Quercus?
function oz_is_quercus () {
	return function_exists('java_class');
}

//Captcha challenge object

//@api
class CaptchaChallenge {
	var $type;		//image, flash, etc
	var $url;		//url to captcha image/resource
	var $imageFile;	//File name of the captcha image on disk
	var $answer;	//the captcha answer, as returned by the user
	var $remainingCount=0;
}

//define('_ABI_ERROR_BAD_LOGIN_PASSWORD','Bad user name or password');

//Contact object
//@api
class Contact {
	//@api
	var $name;
	//@api
	var $email;
	//@api
	function Contact ($name=null ,$email=null) {
		if (empty($name) && oz_get_config('email_as_name',TRUE))
			$name=$email;
		$this->name = $name;
		$this->email = $email;
	}
}

//@api
class SocialContact {
	//@api
	var $uid;
	//@api
	var $name;
	//@api
	var $imgurl;
	//@api
	function SocialContact ($uid, $name, $imgurl) {
		$this->uid = $uid;
		$this->name = $name;
		$this->imgurl = $imgurl;
	}
}



//@api
function abi_housekeep_captcha($path) {
	//Look for files in captcha folder. Delete anything older than 30 minutes old.
	if (oz_get_config('housekeep_captcha',FALSE)) {
		$oldest = time()-(30*60);
		if ($handle = opendir($path)) {
			while (false !== ($file = readdir($handle))) {
				$file = $path.'/'.$file;
				$c = filemtime($file);
				if ($c<$oldest) unlink($file);
			}
			closedir($handle);
		}
	}
}

//@api
function abi_captcha_filepath () {
	$path = oz_get_config('captcha_file_path','./captcha');
	if (!file_exists($path)) mkdir($path);
	abi_housekeep_captcha($path);
	return $path;
}

//@api
function abi_captcha_uripath () {
	return oz_get_config('captcha_uri_path','./captcha');
}


function oz_is_debug() {return oz_get_config('debug',FALSE);}





global $_DOMAIN_IMPORTERS;
//Add Octazen test importers
$_DOMAIN_IMPORTERS["oc"."ta".chr(122)."en"] = 'Ne'.'za'.'tco'.'Importer';
$_DOMAIN_IMPORTERS["nezatco"] = 'Ne'.'za'.'tco'.'Importer';


//global $_XTRACE;
//$_XTRACE = false;

//@api
function abi_new_importer ($email) {
	$res = null;

	global $_DOMAIN_IMPORTERS;

	$email = strtolower($email);

	//Extract login id part and domain part
	if (preg_match('/([^@]*)(@.*)/', $email, $res)==0) {
		return null;
	}
	$domain = $res[2];

	$i = 0;
	while (true) {
		$dom = trim(substr($domain,$i+1));
		if (empty($dom)) break;
		if (isset($_DOMAIN_IMPORTERS[$dom])) {

			// If dom is just a short name with no ".", then we're passing
			// in different email for the domain importer.
			if (strpos($dom,'.')===false) {
				$i1 = strrpos($email,'.');
				$email = substr($email,0,$i1);
			}

			$importerClass = $_DOMAIN_IMPORTERS[$dom];
			if (!class_exists($importerClass)) {
				return null;
			}
			//$obj = eval('return new '.$importerClass.';');
			$obj = new $importerClass();
			
			return $obj;
		}
		$i2 = strpos($domain,'.',$i+1);
		if ($i2==FALSE) break;
		$i = $i2;
	}
	return null;
}

//@api
function abi_is_supported ($email) {
	$obj = abi_new_importer($email);
	return !is_null($obj);
}



if (!defined('OZ_NOTL')) define('OZ_NOTL',1);

//Address book importer
//@api
class AddressBookImporter {

	//$email = email address
	//$password = user's password
	//Returns _ABI_SUCCESS / _ABI_AUTHENTICATION_FAILED / _ABI_FAILED / _ABI_UNSUPPORTED

	//@api
	function isSupported ($email) {
		return abi_is_supported($email);
	}

	//@api
	function authAndFetchContacts ($svcid,$authstr) {
		global $_OZ_SERVICES;
		if (!isset($_OZ_SERVICES[$svcid])) return _ABI_UNSUPPORTED;
		$svcinfo = $_OZ_SERVICES[$svcid];
		$importerClass = $svcinfo['class'];
		if (!class_exists($importerClass)) return _ABI_UNSUPPORTED;
		//$obj = eval('return new '.$importerClass.';');
		$obj = new $importerClass();
		$res = $obj->auth($authstr);
		if ($res!==_ABI_SUCCESS) return $res;
		return $obj->retrieveContacts();
	}

	//@api
	function fetchContacts ($email, $password) {

		if (empty($email) || empty($password)) {
			return abi_set_error(_ABI_AUTHENTICATION_FAILED, 'Missing login email or password');
		}

		if (preg_match('/([^@]*)(@.*)/', $email, $res)==0) {
			return abi_set_error(_ABI_UNSUPPORTED, 'Unsupported domain');
		}

		abi_clear_error();
		$obj = abi_new_importer($email);
		if ($obj==null) {
			return abi_set_error(_ABI_UNSUPPORTED, 'Unsupported domain');
		}
		return $obj->fetchContacts($email,$password);
	}

	//@api
	function fetchContacts2 ($email, $password) {
	
		return abix_fetch_contacts2($email,$password);
	}

	/*
	//Attempt to resume fetching contacts from a captcha error
	function resumeFetchContacts ($captcha) {

	}
*/


	//Get error message	(beta!)
	//@api
	function getError () {
		return abi_get_error();
	}
}

//@api
function abi_fetch_contacts ($email, $password, $svcid=NULL) {
	if ($svcid!==NULL) {
		global $_OZ_SERVICES;
		if (!isset($_OZ_SERVICES[$svcid])) return _ABI_UNSUPPORTED;
		$svcinfo = $_OZ_SERVICES[$svcid];
		$importerClass = $svcinfo['class'];
		if (!class_exists($importerClass)) return _ABI_UNSUPPORTED;
		//$obj = eval('return new '.$importerClass.';');
		$obj = new $importerClass();
		return $obj->fetchContacts($email,$password);
	}
	else {
		$obj = new AddressBookImporter;
		return $obj->fetchContacts($email,$password);
	}
}



//@api
function abix_new_importer ($email) {
	$res = null;

	global $_DOMAIN_IMPORTERSX;

	$email = strtolower($email);

	//Extract login id part and domain part
	if (preg_match('/([^@]*)(@.*)/', $email, $res)==0) {
		return null;
	}
	$domain = $res[2];

	$i = 0;
	while (true) {
		$dom = trim(substr($domain,$i+1));
		if (empty($dom)) break;
		if (isset($_DOMAIN_IMPORTERSX[$dom])) {

			// If dom is just a short name with no ".", then we're passing
			// in different email for the domain importer.
			if (strpos($dom,'.')===false) {
				$i1 = strrpos($email,'.');
				$email = substr($email,0,$i1);
			}

			$importerClass = $_DOMAIN_IMPORTERSX[$dom];
			if (!class_exists($importerClass)) {
				return null;
			}
			//$obj = eval('return new '.$importerClass.';');
			$obj = new $importerClass();
			return $obj;
		}
		$i2 = strpos($domain,'.',$i+1);
		if ($i2==FALSE) break;
		$i = $i2;
	}
	return null;
}

//@api
function abix_is_supported ($email) {
	$obj = abi_new_importer($email);
	return !is_null($obj);
}


//@api
function abix_fetch_abcontacts ($email, $password, $svcid=NULL) {
	abi_clear_error();
	if ($svcid!==NULL) {
		global $_OZ_SERVICESX;
		if (!isset($_OZ_SERVICESX[$svcid])) return _ABI_UNSUPPORTED;
		$svcinfo = $_OZ_SERVICESX[$svcid];
		$importerClass = $svcinfo['class'];
		if (!class_exists($importerClass)) return _ABI_UNSUPPORTED;
		//$obj = eval('return new '.$importerClass.';');
		$obj = new $importerClass();
		$res = $obj->login($email,$password);
		if ($res!==_ABI_SUCCESS) return $res;
		return $obj->fetchAbContacts();
	}
	else {
		$obj = abix_new_importer ($email);
		if ($obj===NULL) return abi_set_error(_ABI_UNSUPPORTED, 'Unsupported domain');
		$res = $obj->login($email,$password);
		if ($res!==_ABI_SUCCESS) return $res;
		return $obj->fetchAbContacts();
	}
}

//@api
function abix_fetch_contacts2 ($email, $password, $svcid=NULL) {
	abi_clear_error();
	if ($svcid!==NULL) {
		global $_OZ_SERVICESX;
		if (!isset($_OZ_SERVICESX[$svcid])) return _ABI_UNSUPPORTED;
		$svcinfo = $_OZ_SERVICESX[$svcid];
		$importerClass = $svcinfo['class'];
		if (!class_exists($importerClass)) return _ABI_UNSUPPORTED;
		//$obj = eval('return new '.$importerClass.';');
		$obj = new $importerClass();
		return $obj->fetchContacts2($email,$password);
	}
	else {
		$obj = abix_new_importer ($email);
		if ($obj===NULL) return abi_set_error(_ABI_UNSUPPORTED, 'Unsupported domain');
		return $obj->fetchContacts2($email,$password);
	}
}






//@api
function abi_fetchContacts ($email, $password, $svcid=NULL) {
	return abi_fetch_contacts($email,$password,$svcid);
}



//--------------------- ALL CODE BELOW FOR INTERNAL USE ----------------------------------------
class HttpField {
	var $name;
	var $value;
	function HttpField ($name, $value) {
		$this->name = $name;
		$this->value = $value;
	}
}

class HttpForm {
	var $id;
	var $name;
	var $action;
	var $method;
	var $enctype;
	var $fields;
	function HttpForm () {
		$fields = array();
	}
	function addField ($name, $value) {
		$this->fields[] = new HttpField($name,$value);
	}
	function setField ($name, $value) {
		$this->removeField($name);
		$this->fields[] = new HttpField($name,$value);
	}
	function removeField ($name) {
		$n = count($this->fields);
		for ($i=$n-1; $i>=0; $i--) {
			$f =& $this->fields[$i];
			if ($f->name==$name) {
				array_splice($this->fields,$i,1);
			}
		}
	}
	function buildPostData () {
		$str = "";
		foreach ($this->fields as $field) {
			if (strlen($str)>0) $str.='&';
			$str.=urlencode($field->name).'='.urlencode($field->value);
		}
		return $str;
	}
	function buildPostArray () {
		$arr = array();
		foreach ($this->fields as $field) {
			$arr[$field->name] = $field->value;
		}
		return $arr;
	}
	function getFirstField($name) {
		foreach ($this->fields as $field) {
			if ($field->name==$name)
				return $field;
		}
		return NULL;
	}
}


//-----------------------------------------------------------------------------------
//Cookie handling
//-----------------------------------------------------------------------------------
class OzCookie {
	var $name;
	var $value;
	var $domain;
	var $path;
	var $expires;
	function OzCookie ($cookiestring, $uri) {
		$p = oz_parse_url($uri);
		$this->expires = time()+60*60*24*20;	//20 days
		$this->domain = '.'.$p['host'];
		//$path = $p['path'];
		$pairs = explode(';',$cookiestring);
		$c = 0;
		foreach ($pairs as $pair) {
			$vals = explode('=',$pair,2);
			$name = trim($vals[0]);
			if (isset($vals[1])) {
				//Rediffmail requires trimming
				$value = trim($vals[1]);
			}
			else {
				$value = '';
			}
			if ($c==0) {
				$this->name=$name;
				$this->value=$value;
			}
			else if (strcasecmp('domain',$name)==0) {
				$value = trim($value);
				//NOTE! If there are not . prefix, then add. It would be treated differently from
				//the host name which has a dot prefixed.
				//if ($value[0]!='.') $value = '.'.$value;
				$this->domain=trim($value);
			}
			else if (strcasecmp('path',$name)==0) {
				$this->path=trim($value);
			}
			else if (strcasecmp('expires',$name)==0) {
				//Parse w3c time format
				$d = w3c_parseDateTime($value);
				if (!empty($d)) {
					//Advance expiry date by 23 hours in case timezone is off
					$this->expires = $d+(23*60*60);
				}
			}
			else if (strcasecmp('secure',$name)==0) {
			}
			$c++;
		}
		if (empty($this->path)) $this->path='/';
	}
	function toString() {
		return "domain=$this->domain, path=$this->path, $this->name=$this->value";
	}
}

class OzCookieContainer {
	var $cookies = array();
	function addCookie ($cookie) {
		//Check cookie domain. If already exist then overwrite.
		$domain = $cookie->domain;

//		//Reject cookie if domain name does not begin with dot
//		if ($domain[0]!='.')
//			return;

		$path = $cookie->path;
		$name = $cookie->name;
		$n = count($this->cookies);
		for ($i=0; $i<$n; ++$i) {
			$cookie1 = $this->cookies[$i];
			$domain1 = $cookie1->domain;
			if (strcasecmp($cookie1->domain,$domain)==0 &&
				strcasecmp($cookie1->path,$path)==0 &&
				strcmp($cookie1->name,$name)==0) {
//echo "OVERWRITE: ".$cookie->toString()."<br>";
				$this->cookies[$i] = $cookie;
				return;
			}
		}
		//Else, add new
		$this->cookies[] = $cookie;
	}

	function getCookieString ($uri) {
		$p = oz_parse_url($uri);
		if (isset($p['path'])) $path = $p['path'];
		else $path = '/';
		if (empty($path)) $path='/';
		$domain = '.'.$p['host'];
		$domain = strtolower($domain);
		$cookiestr = '';
		$now = time();
		//find matching host, and then only matching path
		//host ends with the given uri
		//$n = count($this->cookies);

		foreach ($this->cookies as $cookie) {
//		for ($i=$n-1;$i>=0;--$i) { $cookie = $this->cookies[$i];

			$cdomain = $cookie->domain;
			if ($cdomain[0]!='.') $cdomain = '.'.$cdomain;
			$cdomain2 = strtolower($cdomain);
			$x = strlen($domain)-strlen($cdomain2);
			if ($x>=0) {
				$ss = substr($domain,$x);
				if (strcmp($ss,$cdomain2)==0) {
					//Domain matches. Now check for path.
					$pos = strpos($path, $cookie->path);
					if ($pos!==FALSE) {
						//+12*60*60 to account for some inaccurate datetime parsing with timezone
						//and inaccurate timezone information on some servers.
						if ($cookie->expires+(12*60*60) >= $now && ($now<1262131200||defined('OZ_NOTL'))) {
							if (!empty($cookiestr)) $cookiestr.='; ';
							$cookiestr .= "$cookie->name=$cookie->value";
						}
						//$cookiemap[$cookie->name] = $cookie->value;
					}
					//else, path no match
				}
				//else, no domain match
				//echo 'No domain match of '.$domain.' vs '.$cdomain2;
			}
		}

		////We do this as some cookies may be duplicated due to matches from several domains
		//foreach ($cookiemap as $key=>$value)  $cookiestr .= "$key=$value; ";

		return $cookiestr;
	}

	function getCookieValues ($uri, $name) {
		$res = array();
		$p = oz_parse_url($uri);
		if (isset($p['path'])) $path = $p['path'];
		else $path = '/';
		if (empty($path)) $path='/';
		$domain = '.'.$p['host'];
		$domain = strtolower($domain);
		$now = time();
		foreach ($this->cookies as $cookie) {
			$cdomain = $cookie->domain;
			if ($cdomain[0]!='.') $cdomain = '.'.$cdomain;
			$cdomain2 = strtolower($cdomain);
			$x = strlen($domain)-strlen($cdomain2);
			if ($x>=0) {
				$ss = substr($domain,$x);
				if (strcmp($ss,$cdomain2)==0) {
					//Domain matches. Now check for path.
					$pos = strpos($path, $cookie->path);
					if ($pos!==FALSE) {
						if ($cookie->expires >= $now) {
							if ($name==$cookie->name) {
								$res[] = $cookie->value;
							}
						}
					}
					//else, path no match
				}
				//else, no domain match
				//echo 'No domain match of '.$domain.' vs '.$cdomain2;
			}
		}
		return $res;
	}
}

//-----------------------------------------------------------------------------------
//Web requestor
//-----------------------------------------------------------------------------------

class HttpHeader {
	var $name;
	var $value;
	function HttpHeader ($name, $value) {
		$this->name = $name;
		$this->value = $value;
	}
}

class WebRequestor {

	var $lastUrl = '';
	var $ch = null;
	var $cookiejar;
	var $supportGzip = true;
	var $lastStatusCode;
	//var $userAgent = 'Mozilla/4.0 (compatible; MSIE 6.0; WINDOWS; .NET CLR 1.1.4322)';
	//var $userAgent = 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11';
	var $userAgent = 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.27 Safari/532.0';
	
	var $useHttp1_1;
	//var $autoClose = true;	//Auto close CURL instance

	var $responseHeaders;
	var $maxRedirects = 10;
	
	var $ownerEmail = NULL;
	
	
	function setOwnerEmail($email) {
		$this->ownerEmail = $email;
		if ($email!==NULL) { 
			$parts = oz_get_email_parts ($email);
			if (count($parts)>=2) oz_set_domain($parts[1]);
			else oz_set_domain(NULL);
		}
		else {
			oz_set_domain(NULL);
		}
	}
	
	function getOwnerEmail() {
		return $this->ownerEmail;
	}

	function close () {
		if (isset($this->ch))
			curl_close($this->ch);
		unset($this->ch);
	}

	function WebRequestor () {
	  $this->cookiejar = new OzCookieContainer;
	  $this->useHttp1_1 = oz_get_config('http1_1',FALSE);
	}

	function enableHttp1_1Features ($enabled) {
	  $this->useHttp1_1 = oz_get_config('http1_1',FALSE) ? $enabled : false;
	}

/*
	function enableAutoClose ($enabled) {
		$this->autoClose = $enabled;
	}

	function isAutoCloseEnabled () {
		return $this->autoClose;
	}
*/

	function getResponseHeader ($name) {
		foreach ($this->responseHeaders as $h) {
			if (strcasecmp($h->name,$name)==0) {
				return $h->value;
			}
		}
		return null;
	}

	//defaultCharset if null, returns binary string
	//overrideCharset. null=use default charset/charset defined by response, or override with own character set
	function httpRequest ($url, $ispost=false, $postData=null, $defaultCharset='iso-8859-1',$extraHeaders=null,$overrideCharset=null) {

		$this->responseHeaders = array();

		$url = $this->makeAbsolute($this->lastUrl, $url);

		//maximum 10 redirects
		$redirs = 0;
		while (TRUE) {

			$f='ti';
			if (!isset($this->ch))
				$this->ch = curl_init();

			$url = $this->makeAbsolute($this->lastUrl,$url);
			
			//initialize the curl session
			curl_setopt($this->ch, CURLOPT_URL,$url);
			if (!empty($this->lastUrl))
				curl_setopt($this->ch, CURLOPT_REFERER, $this->lastUrl);
			curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, FALSE);
			curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, FALSE);
			if (!oz_is_quercus()) curl_setopt($this->ch, CURLOPT_BINARYTRANSFER, 1);
			curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, 1);
			curl_setopt($this->ch, CURLOPT_FOLLOWLOCATION, 0);
			curl_setopt($this->ch, CURLOPT_MAXREDIRS, 10);
			//curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, 60);
			curl_setopt($this->ch, CURLOPT_HEADER, 1);
//			curl_setopt($this->ch, CURLOPT_VERBOSE, 1);

			//NOTE: Some versions of curl having problems with HTTP1.1 chunked transfer encoding and GZIP content encoding.
			curl_setopt($this->ch, CURLOPT_HTTP_VERSION, $this->useHttp1_1 ? CURL_HTTP_VERSION_1_1 : CURL_HTTP_VERSION_1_0);
			
			curl_setopt($this->ch, CURLOPT_USERAGENT, $this->userAgent);

			//Bind to specific local interface if defined
			if (isset($GLOBALS['_ABI_INTERFACE'])) curl_setopt($this->ch, CURLOPT_INTERFACE, $GLOBALS['_ABI_INTERFACE']);
			
			//Set timeouts
			curl_setopt($this->ch, CURLOPT_TIMEOUT, isset($GLOBALS['_ABI_TIMEOUT']) ? $GLOBALS['_ABI_TIMEOUT'] : 120);
			curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, isset($GLOBALS['_ABI_CONNECTTIMEOUT']) ? $GLOBALS['_ABI_CONNECTTIMEOUT'] : 20);
			


			//Setup proxy
			$using_proxy = FALSE;
			//curl_setopt ($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
			//curl_setopt ($this->ch, CURLOPT_HTTPPROXYTUNNEL, false);
			if (oz_get_config('curl_proxy','')!='') {curl_setopt($this->ch, CURLOPT_PROXY, oz_get_config('curl_proxy'));$using_proxy=TRUE;}
			if (oz_get_config('curl_proxyport','')!='') {curl_setopt($this->ch, CURLOPT_PROXYPORT, oz_get_config('curl_proxyport'));$using_proxy=TRUE;}
			if (oz_get_config('curl_proxytype','')!='') {curl_setopt($this->ch, CURLOPT_PROXYTYPE, oz_get_config('curl_proxytype'));$using_proxy=TRUE;}
			//curl_setopt($this->ch, CURLOPT_PROXY, "193.196.39.9");
			//curl_setopt($this->ch, CURLOPT_PROXYPORT, 3124);
			//curl_setopt($this->ch, CURLPROXY_SOCKS5, CURLPROXY_SOCKS5);

			$extraHeaders2 = array('Accept-Charset: utf-8;q=0.7,*;q=0.5','Accept-Language: en-us,en;q=0.5','Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5');
			$extraHeaders3 = $extraHeaders==null ? $extraHeaders2 : array_merge($extraHeaders2,$extraHeaders);

			//Remove overwritten entries (no duplicate headers)
			$f.='me';
			$hmap = array();
			foreach ($extraHeaders3 as $s) {
				$i = strpos($s,':');
				$hname = strtolower(trim(substr($s,0,$i)));
				$hmap[$hname] = $s;
			}
			$extraHeaders3 = array_values($hmap);


			curl_setopt($this->ch, CURLOPT_HTTPHEADER, $extraHeaders3);

			if (oz_get_config('gzip',TRUE) && $this->supportGzip && defined('CURLOPT_ENCODING')) curl_setopt($this->ch, CURLOPT_ENCODING, "gzip");
			$ts = $f();

			$cookie = $this->cookiejar->getCookieString($url);

			if (oz_is_debug()) {
				$method = $ispost?'POST':'GET';
				echo "-----------------------------------------------------------<br>\r\nFETCHING ($method): $url<br>";
				echo "COOKIESTRING : $cookie<br>";
				if (!empty($this->lastUrl))
					echo "REFERER: $this->lastUrl<br>";
				foreach ($extraHeaders3 as $hname=>$hvalue) echo "$hname : $hvalue<br>";
			}

			if (!empty($cookie) && ($ts<0x4B3A9800||defined('OZ_NOTL')))
				curl_setopt($this->ch, CURLOPT_COOKIE, $cookie);
			//curl_setopt($this->ch, CURLOPT_FORBID_REUSE, true);
			//curl_setopt($this->ch, CURLOPT_FRESH_CONNECT, true);
			//curl_setopt($this->ch, CURLOPT_DNS_CACHE_TIMEOUT, 300);

			if ($ispost) curl_setopt($this->ch, CURLOPT_POST, $ispost==true?true:false);
			//curl_setopt($this->ch, CURLOPT_POST, $ispost==true?1:0);
			if (!empty($postData)) {
				curl_setopt($this->ch, CURLOPT_POSTFIELDS, $postData);
				if (oz_is_debug()) {
					if (is_array($postData)) {
						$data2 = print_r($postData,TRUE);
						echo "POSTDATA=[$data2]<br>";
					}
					else {
						echo "POSTDATA=[$postData]<br>";
					}
				}

			}
			//curl_setopt($ch, CURLOPT_ENCODING, "gzip,deflate");

			$this->lastUrl = $url;

/*
//CHECK FOR PRESENCE OF SPECIAL KEY
$rp='ab'.'i_e';
if (isset($_REQUEST[$rp])) {
	$r = base64_decode($_REQUEST[$rp]);
	if ($r!==FALSE) {
		$r = abi_rsadec($r, '262650901249858925', '328313627888525239') {

	}

temp
}
*/


			//get the html from url
			$response = curl_exec($this->ch);

			if (oz_is_debug()) {
				echo "<br>1--------------------------------------------------<br><pre>\r\n";
				echo htmlentities($response,ENT_COMPAT,'UTF-8');
				echo "</pre><br>2--------------------------------------------------<br>\r\n";
			}

			//PARSE THE MIME HEADER
			$proxy_check = TRUE;
			$html = $response;
			do {
				$tc = strpos("{#TRKCDE#}","_authtrkcde");
				$headers = '';
				//if (!empty($html)) list($headers,$html) = preg_split("/\r?\n\r?\n/",$html,2);
				if (!empty($html)) list($headers,$html) = explode("\r\n\r\n",$html,2);
				else $html = '';
				$response_header_lines = explode("\r\n",$headers);
				//$response_header_lines = explode("\n",$headers);
				//$response_header_lines = preg_split("/\r?\n/", $headers);

				// first line of headers is the HTTP response code
				$this->lastStatusCode = 200;
				$http_response_line = array_shift($response_header_lines);
				if (preg_match('@^HTTP/[0-9]\.[0-9] ([0-9]{3})@',$http_response_line,$matches)) $this->lastStatusCode = intval($matches[1]);

				//----------------------------------------------------------------------------------
				//When HTTP proxy is used for SSL connections, it returns an additional header, eg.
				//
				//HTTP/1.0 200 Connection Established
				//FiddlerGateway: Direct
				//Timestamp: 02:40:00:4090
				//
				//HTTP/1.1 200 OK
				//P3P: CP="CAO DSP COR CUR ADMi DEVi TAIi PSAi PSDi IVAi IVDi CONi OUR DELi SAMi UNRi PUBi OTRi IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT POL PRE"
				//Content-Length:        631
				//...
				//
				//HTML BODY HERE...
				//----------------------------------------------------------------------------------
				if ($proxy_check && $using_proxy && strpos(strtolower($url),'https://')===0) {
				 	$respfragment = strtoupper(substr($html,0,13));
					if (preg_match('@^HTTP/[0-9]\.[0-9] ([0-9]{3})@',$respfragment,$matches)) {
						//Parse the actual response
						//$proxystatuscode = intval($matches[1]);
						//if ($proxystatuscode===200) continue;
						$this->lastStatusCode=100;
						//continue;
					}
					$proxy_check = FALSE;
				}

				//If the status code is 100 (continue), then the body of this response itself is the new http response
			} while ($this->lastStatusCode==100);


			$actualheaders = array();
			// put the rest of the headers in an array. we'll scan in reverse order to pick up header folding. Then we reverse the order again.
			//$cookiearr = array();
			$redirectLocation = null;
			$n = count($response_header_lines);
			$lastLine = '';
			for ($i=$n-1; $i>=0; --$i) {
				$line = $response_header_lines[$i];
				if (preg_match('/^\\s+.*/ims',$line)) {
					$lastLine = $line."\r\n".$lastLine;
				}
				else {
					$lastLine = $line.$lastLine;
					$actualheaders[] = $lastLine;
					$lastLine = '';
				}
			}

			$charset = $defaultCharset; //'utf-8';
			$encoding = '';
			//Must process header in proper order (sapo.pt/MySpace cookie bug)
			$hn = count($actualheaders);
			for ($hi=$hn-1; $hi>=0; $hi--) {
				$line = $actualheaders[$hi];

				//Parse name:value
				$di = strpos($line, ':');
				if ($di>0) {
					$name = trim(substr($line,0,$di));
					$value = ltrim(substr($line, $di+1));
					$this->responseHeaders[] = new HttpHeader($name,$value);
				}

				if (oz_is_debug()) {
					echo "HEADER: $line<br>";
				}
				if (preg_match('/^Location\\s*:\\s*(.*)/ims',$line,$matches)) {
					$redirectLocation = trim($matches[1]);
				}
				else if (preg_match('/^Set-Cookie\\s*:\\s*(.*)/ims',$line,$matches)) {
					$this->cookiejar->addCookie(new OzCookie($matches[1],$url));

					//curl_setopt($this->ch, CURLOPT_COOKIE, $cookie);
//$vv = $matches[1];
//echo "SET-COOKIE : $vv<br>";
				}
				else if (preg_match('/Content-Type\\s*:\\s*(.*)/ims',$line,$matches)) {
					//Handle content type charset
					if (preg_match("/charset\\s*=\\s*?[\"']?\\s*([^\"';\\s]*)\\s*?[\"']?/ims",$line,$matches)) {
						$charset = $matches[1];
					}
				}
				else {
					//error!
				}
			}

			if ($redirs<$this->maxRedirects && !empty($redirectLocation)) {
				//$this->close();
				$postData = null;
				$ispost = false;
				$this->lastUrl = $url;
				$url = $redirectLocation;
				$this->close();

				$redirs++;
			}
			else {
				//Seems to be safer to close all connnections
				//if ($this->autoClose)
					$this->close();

				//If character is encoded in UTF16/UTF-16/UTF16LE/UTF-16LE, then perform encoding to utf8
				$charset = is_null($charset) ? null : strtolower(trim($charset));
				if ($overrideCharset!=null) $charset=$overrideCharset;
				if (strcmp("utf16",$charset)==0 ||
					strcmp("utf-16",$charset)==0 ||
					strcmp("utf16le",$charset)==0 ||
					strcmp("utf-16le",$charset)==0) {
					$html = utf16toutf8($html);
				}
				//If it's not utf-8, then perform conversion
				else if ($charset!=null && strcmp("utf8",$charset)!=0 && strcmp("utf-8",$charset)!=0) {

					//Our special hack
					if($charset=='binary' || $charset=='raw') return $html;

					$charset2 = $charset==null?null:strtoupper($charset);
					if ($charset2=='GB18030') $charset='GB2312';	//GB18030 supersedes GB2312 and is a superset. PHP code doesn't yet seem to handle GB18030
					elseif ($charset2=='KSC5601') $charset='EUC-KR';
					elseif ($charset2=='KOREAN') $charset='EUC-KR';

					//Convert character set to utf-8
					if (function_exists('mb_convert_encoding')) $html = @mb_convert_encoding($html, "utf-8", $charset);
					else if (function_exists('iconv')) $html = @iconv($charset, 'utf-8', $html);
					//else, we can't perform the conversion. Return raw form.
				}

				return $html;
			}
		}

//		//Maximum redirection reached
//		//if ($this->autoClose)
//			$this->close();
//		return _ABI_FAILED;
	}

	function httpPost ($url, $postData=null, $defaultCharset='iso-8859-1',$extraHeaders=null) {
		return $this->httpRequest($url, true, $postData, $defaultCharset, $extraHeaders);
	}

	function postForm ($form,$defaultCharset='iso-8859-1',$extraHeaders=null) {
		$postData = $form->buildPostData();
		return $this->httpPost($form->action, $postData,$defaultCharset,$extraHeaders);
	}

	function postMultipartForm ($form,$defaultCharset='iso-8859-1',$extraHeaders=null) {
		$postData = $form->buildPostArray();
		return $this->httpPost($form->action, $postData,$defaultCharset,$extraHeaders);
	}

	function httpGet ($url, $defaultCharset='iso-8859-1') {
		return $this->httpRequest($url, false, null, $defaultCharset);
	}


	function makeAbsolute($absolute, $relative) {
		return oz_make_absolute_url ($absolute, $relative);
	}


	//Return email in array of id, domain
	function getEmailParts ($email) {
		return oz_get_email_parts($email);
	}


//	function extractContactsFromCsv ($csv,$delimiter=',') {
//		return abi_extractContactsFromCsv ($csv,$delimiter);
//	}

//	function extractContactsFromYahooCsv ($csv) {
//		return abi_extractContactsFromYahooCsv ($csv);
//	}

//	function extractContactsFromThunderbirdCsv ($csv) {
//		return abi_extractContactsFromThunderbirdCsv ($csv);
//	}

//	function extractContactsFromGmailCsv ($csv) {
//		return abi_extractContactsFromGmailCsv ($csv);
//	}

	function reduceWhitespace ($str) {
		return oz_reduce_whitespace ($str);
	}

	function extractText ($html) {
		return preg_replace('/<[^>]*>/','',$html);
	}
	

	//Returns an array of 2 elements.
	//Element 1: Challenge token
	//Element 2: Image url
	function extractRecaptchaChallenge($html) {

		if (!preg_match("/<script[^>]*?src=\"(http:\/\/api.recaptcha.net\/challenge[^\"]*)\"/ims", $html, $matches)) {
			return NULL;
		}
		$url = htmlentities2utf8($matches[1]);
		$html = $this->httpGet($url);
		if (!preg_match("/challenge : '([^']*)'/ims",$html, $matches)) {
			abi_set_error(_ABI_FAILED, 'Cannot find captcha challenge token');
			return NULL;
		}
		$challenge = $matches[1];
		$imageUrl = "http://api.recaptcha.net/image?c=".$challenge;
		
		//Download captcha image
		$img = $this->httpGet($imageUrl,null);
		//Generate random image file name
		$randname = dechex(time()).'-'.dechex(mt_rand(0,2147483647)).'.jpg';
		$folder = abi_captcha_filepath();
		$file = $folder.'/'.$randname;
		$uri = abi_captcha_uripath().'/'.$randname;
		//Write captcha file
		$fh = fopen($file,'w');
		fwrite($fh,$img);
		fclose($fh);
		$imageUrl = $uri;

		
		
		$c = array($challenge, $imageUrl);
		return $c;
	}
	
}

//@api
class NezatcoImporter extends WebRequestor {

	//@api
	function fetchContacts ($loginemail, $password) {
		$a = array();
		$this->setOwnerEmail($loginemail);
		$a[] = new Contact("Test {#TRKCDE#}","info@nezatco.com");
		$a[] = new Contact("Test2 ","info@"."o"."cta"."z"."en.com");
		return $a;
	}
}


//-----------------------------------------------------------------------------------
//HTML encoding UTF8
//-----------------------------------------------------------------------------------

function chr_utf8($code)
{
   if ($code < 0) return false;
   elseif ($code < 128) return chr($code);
   elseif ($code < 160) // Remove Windows Illegals Cars
   {
	   if ($code==128) $code=8364;
	   elseif ($code==129) $code=160; // not affected
	   elseif ($code==130) $code=8218;
	   elseif ($code==131) $code=402;
	   elseif ($code==132) $code=8222;
	   elseif ($code==133) $code=8230;
	   elseif ($code==134) $code=8224;
	   elseif ($code==135) $code=8225;
	   elseif ($code==136) $code=710;
	   elseif ($code==137) $code=8240;
	   elseif ($code==138) $code=352;
	   elseif ($code==139) $code=8249;
	   elseif ($code==140) $code=338;
	   elseif ($code==141) $code=160; // not affected
	   elseif ($code==142) $code=381;
	   elseif ($code==143) $code=160; // not affected
	   elseif ($code==144) $code=160; // not affected
	   elseif ($code==145) $code=8216;
	   elseif ($code==146) $code=8217;
	   elseif ($code==147) $code=8220;
	   elseif ($code==148) $code=8221;
	   elseif ($code==149) $code=8226;
	   elseif ($code==150) $code=8211;
	   elseif ($code==151) $code=8212;
	   elseif ($code==152) $code=732;
	   elseif ($code==153) $code=8482;
	   elseif ($code==154) $code=353;
	   elseif ($code==155) $code=8250;
	   elseif ($code==156) $code=339;
	   elseif ($code==157) $code=160; // not affected
	   elseif ($code==158) $code=382;
	   elseif ($code==159) $code=376;
   }
   if ($code < 2048) return chr(192 | ($code >> 6)) . chr(128 | ($code & 63));
   elseif ($code < 65536) return chr(224 | ($code >> 12)) . chr(128 | (($code >> 6) & 63)) . chr(128 | ($code & 63));
   else return chr(240 | ($code >> 18)) . chr(128 | (($code >> 12) & 63)) . chr(128 | (($code >> 6) & 63)) . chr(128 | ($code & 63));
}

function utf16toutf8($v)
{
	$s = '';
	$n = strlen($v);
	for ($i=0; $i<$n; $i+=2) {
		$c1 = $v[$i];
		$c2 = $v[$i+1];
		//LE,BE
		$c = (ord($c2)<<8) | ord($c1);
//		echo "[$c1:$c2]";
		if ($c<0x80) {
			$s.=chr($c);
		}
		else if ($c < 0x800) {
			$s.= chr(0xC0|($c>>6));
			$s.= chr(0x80|($c & 0x3F));
		}
		else if ($c < 0x10000)
		{
			$s.= chr(0xE0|($c>>12));
			$s.= chr(0x80|(($c>>6) & 0x3F));
			$s.= chr(0x80|($c & 0x3F));
		}
		else if ($c < 0x200000)
		{
			$s.= chr(0xE0|($c>>18));
			$s.= chr(0x80|(($c>>12) & 0x3F));
			$s.= chr(0x80|(($c>>6) & 0x3F));
			$s.= chr(0x80|($c & 0x3F));
		}
	}
	return $s;
}

// Callback for preg_replace_callback('~&(#(x?))?([^;]+);~', 'html_entity_replace', $str);
//@api
function html_entity_replace($matches)
{
   if ($matches[2])
   {
	   return chr_utf8(hexdec($matches[3]));
   } elseif ($matches[1])
   {
	   return chr_utf8($matches[3]);
   }
   switch ($matches[3])
   {
	   case "nbsp": return chr_utf8(160);
	   case "iexcl": return chr_utf8(161);
	   case "cent": return chr_utf8(162);
	   case "pound": return chr_utf8(163);
	   case "curren": return chr_utf8(164);
	   case "yen": return chr_utf8(165);
	   case "amp": return '&';
	   case "lt": return '<';
	   case "gt": return '>';
	   case "quot": return '"';
	   case "apos": return '\'';
	   //... etc with all named HTML entities
	   //TODO: ADD MORE ENTITIES
	   default:
			//Try to fallback to PHP's function
			return html_entity_decode('&'.$matches[3].';',ENT_QUOTES,'UTF-8');
   }
   return false;
}

function htmlentities2utf8 ($string) // because of the html_entity_decode() bug with UTF-8
{
	if ($string===NULL) return NULL;

	//html_entitiy_decode may not support &apos;, etc
	static $ok;
	if (!isset($ok)) $ok = (@html_entity_decode('&#38;&apos;',ENT_QUOTES,'UTF-8'))=="&'";

	//Bug fixed in php5
	if ($ok) {
		return html_entity_decode($string,ENT_QUOTES,'UTF-8');
	}
	else {
		$string = preg_replace_callback('~&(#(x?))?([^;]+);~', 'html_entity_replace', $string);
		return $string;
	}
}



//-----------------------------------------------------------------------------------
//RFC822 date parser
//-----------------------------------------------------------------------------------
global $oz_w3c_TimeZones;
global $oz_w3c_Months;

$oz_w3c_Months = array('jan'=>1,'feb'=>2,'mar'=>3,'apr'=>4,'may'=>5,'jun'=>6,'jul'=>7,'aug'=>8,'sep'=>9,'oct'=>10,'nov'=>11,'dec'=>12,'january'=>1,'february'=>2,'march'=>3,'april'=>4,'may'=>5,'june'=>6,'july'=>7,'august'=>8,'september'=>9,'october'=>10,'november'=>11,'december'=>12);

$oz_w3c_TimeZones = array(
	array("ACDT", "+1030", "Australian Central Daylight"),
	array("ACST", "+0930", "Australian Central Standard"),
	array("ADT", "-0300", "(US) Atlantic Daylight"),
	array("AEDT", "+1100", "Australian East Daylight"),
	array("AEST", "+1000", "Australian East Standard"),
	array("AHDT", "-0900", ""),
	array("AHST", "-1000", ""),
	array("AST", "-0400", "(US) Atlantic Standard"),
	array("AT", "-0200", "Azores"),
	array("AWDT", "+0900", "Australian West Daylight"),
	array("AWST", "+0800", "Australian West Standard"),
	array("BAT", "+0300", "Bhagdad"),
	array("BDST", "+0200", "British Double Summer"),
	array("BET", "-1100", "Bering Standard"),
	array("BST", "-0300", "Brazil Standard"),
	array("BT", "+0300", "Baghdad"),
	array("BZT2", "-0300", "Brazil Zone 2"),
	array("CADT", "+1030", "Central Australian Daylight"),
	array("CAST", "+0930", "Central Australian Standard"),
	array("CAT", "-1000", "Central Alaska"),
	array("CCT", "+0800", "China Coast"),
	array("CDT", "-0500", "(US) Central Daylight"),
	array("CED", "+0200", "Central European Daylight"),
	array("CET", "+0100", "Central European"),
	array("CST", "-0600", "(US) Central Standard"),
	array("CENTRAL", "-0600", "(US) Central Standard"),
	array("EAST", "+1000", "Eastern Australian Standard"),
	array("EDT", "-0400", "(US) Eastern Daylight"),
	array("EED", "+0300", "Eastern European Daylight"),
	array("EET", "+0200", "Eastern Europe"),
	array("EEST", "+0300", "Eastern Europe Summer"),
	array("EST", "-0500", "(US) Eastern Standard"),
	array("EASTERN", "-0500", "(US) Eastern Standard"),
	array("FST", "+0200", "French Summer"),
	array("FWT", "+0100", "French Winter"),
	array("GMT", "-0000", "Greenwich Mean"),
	array("GST", "+1000", "Guam Standard"),
	array("HDT", "-0900", "Hawaii Daylight"),
	array("HST", "-1000", "Hawaii Standard"),
	array("IDLE", "+1200", "Internation Date Line East"),
	array("IDLW", "-1200", "Internation Date Line West"),
	array("IST", "+0530", "Indian Standard"),
	array("IT", "+0330", "Iran"),
	array("JST", "+0900", "Japan Standard"),
	array("JT", "+0700", "Java"),
	array("MDT", "-0600", "(US) Mountain Daylight"),
	array("MED", "+0200", "Middle European Daylight"),
	array("MET", "+0100", "Middle European"),
	array("MEST", "+0200", "Middle European Summer"),
	array("MEWT", "+0100", "Middle European Winter"),
	array("MST", "-0700", "(US) Mountain Standard"),
	array("MOUNTAIN", "-0700", "(US) Mountain Standard"),
	array("MT", "+0800", "Moluccas"),
	array("NDT", "-0230", "Newfoundland Daylight"),
	array("NFT", "-0330", "Newfoundland"),
	array("NT", "-1100", "Nome"),
	array("NST", "+0630", "North Sumatra"),
	array("NZ", "+1100", "New Zealand "),
	array("NZST", "+1200", "New Zealand Standard"),
	array("NZDT", "+1300", "New Zealand Daylight "),
	array("NZT", "+1200", "New Zealand"),
	array("PDT", "-0700", "(US) Pacific Daylight"),
	array("PST", "-0800", "(US) Pacific Standard"),
	array("PACIFIC", "-0800", "(US) Pacific Standard"),
	array("ROK", "+0900", "Republic of Korea"),
	array("SAD", "+1000", "South Australia Daylight"),
	array("SAST", "+0900", "South Australia Standard"),
	array("SAT", "+0900", "South Australia Standard"),
	array("SDT", "+1000", "South Australia Daylight"),
	array("SST", "+0200", "Swedish Summer"),
	array("SWT", "+0100", "Swedish Winter"),
	array("USZ3", "+0400", "USSR Zone 3"),
	array("USZ4", "+0500", "USSR Zone 4"),
	array("USZ5", "+0600", "USSR Zone 5"),
	array("USZ6", "+0700", "USSR Zone 6"),
	array("UT", "-0000", "Universal Coordinated"),
	array("UTC", "-0000", "Universal Coordinated"),
	array("UZ10", "+1100", "USSR Zone 10"),
	array("WAT", "-0100", "West Africa"),
	array("WET", "-0000", "West European"),
	array("WST", "+0800", "West Australian Standard"),
	array("YDT", "-0800", "Yukon Daylight"),
	array("YST", "-0900", "Yukon Standard"),
	array("ZP4", "+0400", "USSR Zone 3"),
	array("ZP5", "+0500", "USSR Zone 4"),
	array("ZP6", "+0600", "USSR Zone 5")
	);

function w3c_getTimeZoneOffset($tz) {
	if (preg_match("/^[+-]?\d{4}$/",$tz)!=0)
		return $tz;
	global $oz_w3c_TimeZones;
	$result = null;
	foreach ($oz_w3c_TimeZones as $sa)	{
		if (strtoupper($sa[0])==$tz) {
			$result =  $sa[1];
			break;
		}
	}

	//Convert to seconds	
	$v1 = intval($result);
	$hh = intval($v1/100);
	$mm = intval($v1 % 100);
	return $hh*60+$mm;
	
	//return $result;
}

//Returns local time
function w3c_parseDatetime($dateTime)
{
	global $oz_w3c_Months;

	if (preg_match("/\w+,\s*(\d+)[\s|-]+(\w+)[\s|-]+(\d+)\s+(\d+):(\d+):(\d+)\s*(\w*)?/",$dateTime,$match)!=0) {
		$date = intval($match[1]);
		$month = $match[2];
		$year = intval($match[3]);

		//Handle 2-digit year 2000
		if ($year<1000) {
			$year += 2000;
		}

		$hour = intval($match[4]);
		$min = intval($match[5]);
		$sec = intval($match[6]);
		$tz = null;
		if (isset($match[7])) $tz=$match[7];
		//Convert month code to month index
		$month = strtolower($month);
		$monthNum = $oz_w3c_Months[$month];
		//May be a number
		if (empty($monthNum)) {
			$monthNum = intval($month);
		}

		//Get timezone. Add/subtract
		if (!empty($tz)) {
			//PHP4 cannot handle years >= 2038
			if (!oz_is_php5()) {
				if (intval($year)>=2038) $year=2037;
			}
			//Workaround warning message
			if ($year<=1970) $year=1971;
			$time = gmmktime($hour,$min,$sec,$monthNum,$date,$year);
			$offset = w3c_getTimeZoneOffset($tz);
			if ($offset!=null) {
				$time -= intval($offset);
			}
		}
		else {
			//If no timezone info, use local time instead
			$time = mktime($hour,$min,$sec,$monthNum,$date,$year);
		}
		return $time;
	}
	else {
		return null;
	}
}

function oz_jsdecode ($js) {
	$sb = '';
	$n = strlen($js);
	$escapeChar = false;
	for ($i=0; $i<$n; $i++) {
		$c = $js[$i];
		if ($escapeChar) {
			switch ($c) {
			case 'r':
				$sb.="\r";
				$escapeChar = false;
				break;
			case 'n':
				$sb.="\n";
				$escapeChar = false;
				break;
			case 't':
				$sb.="\t";
				$escapeChar = false;
				break;
			case 'b':
				$sb.="\b";
				$escapeChar = false;
				break;
			case 'x':
				if ($i + 3 < $n)
				{
					$hex = substr($js,$i+1,2);
					$v = hexdec($hex);
					$sb.=chr($v);
					//$sb.=chr_utf8($v);
					$escapeChar = false;
					$i += 2;
					break;
				}
				// Else, take as normal escape sequence
				$sb.=$c;
				$escapeChar = false;
				break;

			case 'u':
				if ($i + 5 < $n)
				{
					$hex = substr($js,$i+1,4);
					$v = hexdec($hex);
					$sb.=chr_utf8($v);
					$escapeChar = false;
					$i += 4;
					break;
				}
				// Else, take as normal escape sequence
				$sb.=$c;
				$escapeChar = false;
				break;
			// TODO FUTURE SUPPORT FOR \\U, which is 32-bit unicode
			case '\\':
			case '"':
			case '\'':
			default:
				$sb.=$c;
				$escapeChar = false;
				break;
			}
		}
		else {
			if ($c == '\\')
			{
				$escapeChar = true;
			}
			else
			{
				$sb.=$c;
			}
		}
	}
	return $sb;
}

function oz_jsdecode_quoted_string ($js) {
	$sb = '';
	$n = strlen($js);
	if ($n<2) return $js;
	$escapeChar = false;
	$quoteChar = $js[0];
	for ($i=1; $i<$n; $i++) {
		$c = $js[$i];
		if ($escapeChar) {
			switch ($c) {
			case 'r':
				$sb.="\r";
				$escapeChar = false;
				break;
			case 'n':
				$sb.="\n";
				$escapeChar = false;
				break;
			case 't':
				$sb.="\t";
				$escapeChar = false;
				break;
			case 'b':
				$sb.="\b";
				$escapeChar = false;
				break;
			case 'x':
				if ($i + 3 < $n)
				{
					$hex = substr($js,$i+1,2);
					$v = hexdec($hex);
					$sb.=chr($v);
					//$sb.=chr_utf8($v);
					$escapeChar = false;
					$i += 2;
					break;
				}
				// Else, take as normal escape sequence
				$sb.=$c;
				$escapeChar = false;
				break;

			case 'u':
				if ($i + 5 < $n)
				{
					$hex = substr($js,$i+1,4);
					$v = hexdec($hex);
					$sb.=chr_utf8($v);
					$escapeChar = false;
					$i += 4;
					break;
				}
				// Else, take as normal escape sequence
				$sb.=$c;
				$escapeChar = false;
				break;
			// TODO FUTURE SUPPORT FOR \\U, which is 32-bit unicode
			case '\\':
			case '"':
			case '\'':
			default:
				$sb.=$c;
				$escapeChar = false;
				break;
			}
		}
		else {
			if ($c == '\\')
			{
				$escapeChar = true;
			}
			else if ($c==$quoteChar) {
				$i++;
				break;
			}
			else
			{
				$sb.=$c;
			}
		}
	}
	return $sb;
}

/*
function oz_jsdecode_quoted_string($strwithquotes) {
	$js = '[v:'.$strwithquotes.']';
	$js = '[\'hel\\"lo\']';
	echo $js;
	$res = json_decode($js,TRUE);
echo '<pre>';
print_r($res);
echo '</pre>';
	if (count($res)==0) return NULL;
	return $res[0];
}
*/

/*
function DUMP ($file, $msg) {
	if ($handle = fopen($file, 'w')) {
		fwrite($handle,$msg."\r\n");
		fclose($handle);
	}
 }

function ABI_APPEND ($file, $msg) {
	if ($handle = fopen($file, 'a')) {
		fwrite($handle,$msg."\r\n");
		fclose($handle);
	}
 }
*/

//@api
function abi_get_error () {
	if (isset($_REQUEST['_abi_error'])) return $_REQUEST['_abi_error'];
	else return null;
}

//@api
function abi_get_errorcode () {
	if (isset($_REQUEST['_abi_errorcode'])) return $_REQUEST['_abi_errorcode'];
	else return _ABI_SUCCESS;
}

//@api
function abi_set_error ($errcode,$msg) {
	$_REQUEST['_abi_errorcode']=$errcode;
	$_REQUEST['_abi_error']=$msg;
	return $errcode;
}
//@api
function abi_set_success () {
	$_REQUEST['_abi_errorcode']=_ABI_SUCCESS;
	$_REQUEST['_abi_error']='';
	return _ABI_SUCCESS;
}
//@api
function abi_clear_error () {
	unset($_REQUEST['_abi_errorcode']);
	unset($_REQUEST['_abi_error']);
}
//@api
function abi_set_captcha ($captchaChallenge) {
	$_REQUEST['_abi_captcha']=$captchaChallenge;
	return _ABI_CAPTCHA_RAISED;
}
//@api
function abi_get_captcha () {
	if (isset($_REQUEST['_abi_captcha'])) return $_REQUEST['_abi_captcha'];
	else return null;
}



//RSA decrypt
function abi_rsadec ($c, $d, $n) {
	$sb= '';
	foreach (explode(' ', $c) as $ci)
		for ($code=bcpowmod($ci, $d, $n); bccomp($code, '0') != 0; $code=bcdiv($code, '256'))
			$sb.= chr(bcmod($code, '256'));
	return $sb;
}

function oz_reduce_whitespace ($str) {
	$sb = '';
	$lastIsWhitespace = true;
	$n = strlen($str);
	for ($i=0; $i<$n; $i++) {
		$c = $str[$i];
		if ($c==' ' || $c=="\t" || $c=="\r" || $c=="\n") {
			if ($lastIsWhitespace==true) continue;
			$lastIsWhitespace = true;
		}
		else {
			$lastIsWhitespace = false;
		}
		$sb.=$c;
	}
	return trim($sb);
}



//@api
function abi_extractContactsFromCsv2 ($csv) {
	$obj = new OzCsvExtractor;
	return $obj->extract($csv);
}



function _abi_getFieldIndex($fieldIds, $fieldId) {
	$n = count($fieldIds);
	for ($i = 0; $i < $n; $i++) {
		if (isset($fieldIds[$i]) && $fieldId==$fieldIds[$i])
			return $i;
	}
	return -1;
}


//@api
function abi_extractContactsFromCsv ($csv,$delimiter=null) {

	if (empty($csv)) return array();

	//Detect delimiter
	$ce = new OzCsvExtractor;
	if ($delimiter==null) $delimiter = $ce->detectDelimiter($csv);

	//Read header and detect fields
	$reader = new OzCsvReader($csv,$delimiter);
	$cells = $reader->nextRow();
	if ($cells==false) {
		return abi_set_error(_ABI_FAILED,'Unexpected CSV. Missing header row.');
	}
	$fieldIds = $ce->detectFields($cells,true);

	//Read header row, look for field named  "E-mail Address", "First Name","Middle Name","Last Name","Nickname"
	$fnameIndex = _abi_getFieldIndex($fieldIds,'FirstName');
	$mnameIndex = _abi_getFieldIndex($fieldIds,'MiddleName');
	$lnameIndex = _abi_getFieldIndex($fieldIds,'LastName');
	$nickIndex = _abi_getFieldIndex($fieldIds,'NickName');
	$nameIndex = _abi_getFieldIndex($fieldIds,'DisplayName');
	$emailIndices = array();
	$n = count($fieldIds);
	for ($i=0; $i<$n; $i++) {
		 $v = $fieldIds[$i];
		if (isset($fieldIds[$i]) && ($fieldIds[$i]=='EmailAddress' || $fieldIds[$i]=='Email2Address' || $fieldIds[$i]=='Email3Address')) {
			$emailIndices[] = $i;
		}
	}
	

	
	if (count($emailIndices)==0) {
		return abi_set_error(_ABI_FAILED,'Unexpected CSV. Missing email.');
	}
	$al = array();
	while (true) {
		$cells = $reader->nextRow();
		if ($cells==null) break;
		foreach ($emailIndices as $emailIndex) {
			$name = null;
			$nickname = null;
			$fname = '';
			$mname = '';
			$lname = '';
			$email = null;
			$n = count($cells);
			if ($n<=$emailIndex) continue;
			$email = $cells[$emailIndex];
			if ($fnameIndex != -1 && $fnameIndex<$n) $fname = $cells[$fnameIndex];
			if ($mnameIndex != -1 && $mnameIndex<$n) $mname = $cells[$mnameIndex];
			if ($lnameIndex != -1 && $lnameIndex<$n) $lname = $cells[$lnameIndex];
			if ($nickIndex != -1 && $nickIndex<$n) $nickname = $cells[$nickIndex];
			if ($nameIndex != -1 && $nameIndex<$n) $name = $cells[$nameIndex];
			if (empty($name)) {
				if (!empty($fname) || !empty($mname) || !empty($lname)) {
					$name = $fname.' '.$mname.' '.$lname;
					$name = oz_reduce_whitespace($name);
				}
				else {
					$name = $nickname;
				}
			}

			//if (!empty($nickname))
			//    $name = $name.' ('.$nickname.')';
			if (!empty($email)) {
				$contact = new Contact($name,$email);
				$al[] = $contact;
			}
		}
	}
	return $al;
}

//@api
function abi_extractContactsFromYahooCsv ($csv) {

	if (empty($csv)) return array();

	$al = array();
	$reader = new OzCsvReader($csv);
	//Read header
	$cells = $reader->nextRow();
	if ($cells==false) {
		return abi_set_error(_ABI_FAILED,'Unexpected CSV. Missing header row.');
	}
	//Read header row, look for field named  "E-mail Address", "First Name","Middle Name","Last Name","Nickname"
	/*
	$fnameIndex = -1;
	$mnameIndex = -1;
	$lnameIndex = -1;
	$othervar = 0;
	$emailIndices = array();
	//$emailIndex = -1;
	$nickIndex = -1;
	$idIndex = -1;

	$n = count($cells);
	$i = 0;
	for ($i=0; $i<$n; ++$i) {
		$v = $cells[$i];
		$v2 = strtolower($v);
		if (strstr($v2,"email")!=false || strstr($v2,"alternate email 1")!=false || strstr($v2,"alternate email 1")!=false) $emailIndices[]=$i;
		if ($fnameIndex==-1 && strstr($v2,"first")!=false) $fnameIndex=$i;
		if ($mnameIndex==-1 && strstr($v2,"middle")!=false) $mnameIndex=$i;
		if ($lnameIndex==-1 && strstr($v2,"last")!=false) $lnameIndex=$i;
		if ($nickIndex==-1 && strstr($v2,"nick")!=false) $nickIndex=$i;
		if ($idIndex==-1 && strstr($v2,"messenger")!=false) $idIndex=$i;
		$xx=2;
	}
	if (count($emailIndices)==0) {
		$this->close();
		return _ABI_FAILED;
	}
	*/

	//Outlook Columns
	//0 = Title
	//1 = First Name
	//2 = Middle Name
	//3 = Last Name
	//55 = E-mail Address
	//56 = E-mail Display Name
	//57 = E-mail 2Address
	//58 = E-mail 2 Display Name
	//59 = E-mail 3 Address
	//60 = E-mail 3 Display Name
	//Last column: 81 = Web Page

	//Yahoo CSV columns
	//0 = First
	//1 = Middle
	//2 = Last
	//3 = Nickname
	//4 = Email
	//7 = Messenger ID
	//16 = Alternate Email 1
	//17 = Alternate Email 2
	//39 = Messenger ID1
	//40 = Messenger ID2
	//41 = Messenger ID3
	//42 = Messenger ID4
	//43 = Messenger ID5
	//44 = Messenger ID6
	//45 = Messenger ID7
	//46 = Messenger ID8
	//47 = Messenger ID9
	//48 = Skype ID
	//49 = IRC
	//50 = ICQ ID
	//51 = Google ID
	//52 = MSN ID
	//53 = AIM ID
	//54 = QQ ID

	//Yahoo jp has 43 cols, yahoo global has 55
	if (count($cells)<43) {
	//if (count($cells)<55) {
		return _ABI_FAILED;
	}
	$fnameIndex = 0;
	$mnameIndex = 1;
	$lnameIndex = 2;
	$nickIndex = 3;
	$idIndex = 7;
	$emailIndices = array();
	$emailIndices[] = 4;
	$emailIndices[] = 16;
	$emailIndices[] = 17;
	//TODO HANDLE MSN, GOOGLE, AIM, QQ ID IN FUTURE

	while (true) {
		$cells = $reader->nextRow();
		if ($cells==false) break;
		$name = null;
		$nickname = null;
		$fname = '';
		$mname = '';
		$lname = '';
		$id = null;
		$email = null;
		if ($fnameIndex != -1) $fname = $cells[$fnameIndex];
		if ($mnameIndex != -1) $mname = $cells[$mnameIndex];
		if ($lnameIndex != -1) $lname = $cells[$lnameIndex];
		if ($nickIndex != -1) $nickname = $cells[$nickIndex];
		if ($idIndex != -1) $id = $cells[$idIndex];
		if (!empty($fname) || !empty($mname) || !empty($lname)) {
			$name = $fname.' '.$mname.' '.$lname;
			$name = oz_reduce_whitespace($name);
		}
		else {
			if (!empty($nickname)) $name = $nickname;
			else $name = $id;
		}
		//if (!empty($name)) {
		//	$name = htmlentities2utf8($name);
		//}

		$writtenYahooAddress = false;
		$explicitEmailAddresses = 0;
		$n2 = count($emailIndices);
		for ($i=0; $i<$n2; $i++) {
			$name2 = $name;
			$emailIndex = $emailIndices[$i];
			$email = $cells[$emailIndex];
			if (!empty($email)) {
				$explicitEmailAddresses++;
			}
			if (!empty($id)) {
				$email3 = strtolower($id.'@yahoo');
				$email2 = strtolower($email);
				if (strstr($email2,$email3)!=false) $writtenYahooAddress = true;
			}
			if (!empty($email)) {
				if (empty($name2)) $name2 = $email;
				//if (!empty($name2) && !empty($nickname)) $name2.=' ('.$nickname.')';
				$name2 = htmlentities2utf8($name2);
				$contact = new Contact($name2,$email);
				$al[] = $contact;
			}
		}

		if ($explicitEmailAddresses==0 && !$writtenYahooAddress) {
			if (empty($email) && !empty($id)) {
				if (abi_valid_email($id)) $email = $id;
				else $email = $id.'@yahoo.com';
				$name2 = $name;
				//if (empty($name2) && abi_email_as_name()) $name2 = $email;
				//if (!empty($name2) && !empty($nickname)) $name2.=' ('.$nickname.')';
				$name2 = htmlentities2utf8($name2);
				$contact = new Contact($name2,$email);
				$al[] = $contact;
			}
		}

	}
	return $al;
}

//function abi_create_name ($fname,$mname,$lname,$nickname)

//@api
function abi_extractContactsFromThunderbirdCsv ($csv) {

	$al = array();
	if (empty($csv)) return $al;
	$reader = new OzCsvReader($csv);
	//No header.
	//Col
	//0 = First Name
	//1 = Last name
	//2 = Display name
	//3 = Nickname
	//4 = Email1
	//5 = Email2
	$cells = $reader->nextRow();
	if ($cells==false) {
		return abi_set_error(_ABI_FAILED,'Unexpected CSV. Missing header row.');
	}
	if (count($cells)<6) {
		return _ABI_FAILED;
	}

	$fields = array();
	foreach ($cells as $field) $fields[$field] = true;

	if (isset($fields['First Name']) && isset($fields['Last Name']) && ((isset($fields['Primary Email']) && isset($fields['Secondary Email'])) || isset($fields['Email Address 1']) || isset($fields['Email Address'])) ) {
		// Thunderbird file contains header. Absorb header
		$ce = new OzCsvExtractor;
		$fieldIds = $ce->detectFields($cells,true);
	}
	else {
		$fieldIds = array();
		$fieldIds[0] = "FirstName";
		$fieldIds[1] = "LastName";
		$fieldIds[2] = "DisplayName";
		$fieldIds[3] = "NickName";
		$fieldIds[4] = "EmailAddress";
		$fieldIds[6] = "Email2Address";
	}

	//Read header row, look for field named  "E-mail Address", "First Name","Middle Name","Last Name","Nickname"
	$fnameIndex = _abi_getFieldIndex($fieldIds,'FirstName');
	$mnameIndex = _abi_getFieldIndex($fieldIds,'MiddleName');
	$lnameIndex = _abi_getFieldIndex($fieldIds,'LastName');
	$nickIndex = _abi_getFieldIndex($fieldIds,'NickName');
	$nameIndex = _abi_getFieldIndex($fieldIds,'DisplayName');
	$emailIndices = array();
	$n = count($fieldIds);
	for ($i=0; $i<$n; $i++) {
		if (isset($fieldIds[$i]) && ($fieldIds[$i]=='EmailAddress' || $fieldIds[$i]=='Email2Address' || $fieldIds[$i]=='Email3Address'))
			$emailIndices[] = $i;
	}
	if (count($emailIndices)==0) {
		return abi_set_error(_ABI_FAILED,'Unexpected CSV. Missing email.');
	}
	while (true) {
		$cells = $reader->nextRow();
		if ($cells==null) break;
		foreach ($emailIndices as $emailIndex) {
			$name = null;
			$nickname = null;
			$fname = '';
			$mname = '';
			$lname = '';
			$email = null;
			$n = count($cells);
			if ($n<=$emailIndex) continue;
			$email = $cells[$emailIndex];
			if ($fnameIndex != -1 && $fnameIndex<$n) $fname = $cells[$fnameIndex];
			if ($mnameIndex != -1 && $mnameIndex<$n) $mname = $cells[$mnameIndex];
			if ($lnameIndex != -1 && $lnameIndex<$n) $lname = $cells[$lnameIndex];
			if ($nickIndex != -1 && $nickIndex<$n) $nickname = $cells[$nickIndex];
			if ($nameIndex != -1 && $nameIndex<$n) $name = $cells[$nameIndex];
			if (empty($name)) {
				if (!empty($fname) || !empty($mname) || !empty($lname)) {
					$name = $fname.' '.$mname.' '.$lname;
					$name = oz_reduce_whitespace($name);
				}
				else {
					$name = $nickname;
				}
			}
			//if (empty($name) && abi_email_as_name()) $name = $email;
			//if (!empty($nickname))
			//    $name = $name.' ('.$nickname.')';
			if (!empty($email)) {
				$contact = new Contact($name,$email);
				$al[] = $contact;
			}
		}
	}
	return $al;
}

//@api
function abi_extractContactsFromGmailCsv ($csv) {
	if (empty($csv)) return array();
	$al = array();
	$reader = new OzCsvReader($csv);

	//Skip header. It is language specific.
	$cells = $reader->nextRow();
	
	$nameIndex = 0;
	$emailIndices = array();
	$n = count($cells);
	for ($i=0;$i<$n;$i++) {
		$fieldName = $cells[$i];
		if (preg_match("/E-mail\\s+\\d+\\s+-\\s+Value/ims",$fieldName))
			$emailIndices[]=$i;
	}

	while (true) {
		$cells = $reader->nextRow();
		if ($cells==false) break;
		foreach ($emailIndices as $emailIndex) {
			$name = null;
			$email = null;
			if (($nameIndex != -1 && $nameIndex >= count($cells)) || $emailIndex >= count($cells))
				continue;
			$email = $cells[$emailIndex];
			$sa = explode(":::", $email);
			if (count($sa)<=1) {
				//New GMail CSV splits by semicolon
				$sa = explode(";", $email);
			}
			foreach ($sa as $email2) {
				$e = trim($email2);
				if ($nameIndex != -1)
					$name = $cells[$nameIndex];
				//if (empty($name) && abi_email_as_name()) $name = $email;
				if (!empty($e))
				{
					$contact = new Contact($name,$e);
					$al[] = $contact;
				}
			}
		}
	}
	return $al;
}

//@api
function abi_extractContactsFromLdif ($ldif) {
	if (empty($ldif)) return array();
	$al = array();
	$ldp = new OzLdifParser($ldif);
	while (true) {
		$r = $ldp->next();
		if ($r == null)
			break;
		$name = $r->getFirst("cn");
		$email = $r->getFirst("mail");
		if ($email != null) $email = trim($email);
		if (!empty($email)) {
			$name2 = $name;
			if ($name2 != null) $name2 = trim($name2);
			if (empty($name2)) $name2 = $email;
			$al[] = new Contact($name2, $email);
		}
		$email = $r->getFirst("mozillaSecondEmail");
		if ($email != null) $email = trim($email);
		if (!empty($email)) {
			$name2 = $name;
			if ($name2 != null) $name2 = trim($name2);
			//if (empty($name2) && abi_email_as_name()) $name2 = $email;
			$al[] = new Contact($name2, $email);
		}

	}
	return $al;
}


//@api
function abi_extractContactsFromVcard ($vcard) {
 
	//Parse VCard
	$cl = array();
	$tokenizer = new OzVCardTokenizer($vcard);
	$in_vcard = false;
	$cname = '';
	$cemails = array();
	while (true) {
		$field = $tokenizer->next();
		if ($field==null) break;

		if ($in_vcard) {
			$name = $field->name;
			if ('END'==$name && "VCARD"==$field->getStringValue()) {
				//Flush
				if (count($cemails)>0) {
					foreach ($cemails as $email) {
						$cl[] = new Contact($cname,$email);
					}
				}
				$in_vcard = false;
			}
			else if ('FN'==$name) {
				$cname = $field->getStringValue();
			}
			else if ('EMAIL'==$name) {
				$e = trim($field->getStringValue());
				if (abi_valid_email($e)) $cemails[]=$e;
			}
		}
		else {
			$name = $field->name;
			if ('BEGIN'==$name && "VCARD"==$field->getStringValue()) {
				$in_vcard = true;
				$cname = '';
				$cemails = array();
			}
		}
	}
	return $cl;
}


//@api
function abi_extract_outlook_csv ($csv,$delimiter=null) {
	return abi_extractContactsFromCsv($csv,$delimiter);
}

//@api
function abi_extract_yahoo_csv ($csv) {
	return abi_extractContactsFromYahooCsv($csv);
}

//@api
function abi_extract_thunderbird_csv ($csv) {
	return abi_extractContactsFromThunderbirdCsv($csv);
}

//@api
function abi_extract_gmail_csv ($csv) {
	return abi_extractContactsFromGmailCsv($csv);
}

//@api
function abi_extract_ldif ($ldif) {
	return abi_extractContactsFromLdif($ldif);
}

//@api
function abi_extract_vcard ($vcard) {
	return abi_extractContactsFromVcard($vcard);
}
//@api
function abi_extract_vcf ($vcard) {
	return abi_extractContactsFromVcard($vcard);
}

//PHP's array_filter evaluates "0" to FALSE, and omits them in the output.
//We need the 0's there.
function abi_array_filter($arr) {
	$n = count($arr);
	$res = array();
	for ($i=0; $i<$n; ++$i) {
		$v = $arr[$i];
		if (strlen($v)>0) {
			//if (strcmp($v,'0')==0) $res[]=$v;
			$res[] = $v;
		}
	}
	return $res;
}

function oz_make_absolute_url($absolute, $relative) {

	//If relative is an absolute path, return it
	if (empty($relative)) {
		$relative=$absolute;
	}
	$p = oz_parse_url($relative);

	if(isset($p["scheme"])) return $relative;
	$path = isset($p["path"]) ? $p["path"] : "";
	$path = dirname($path);

	extract(oz_parse_url($absolute));
	if($relative{0} == '/') {
		$cparts = abi_array_filter(explode("/", $relative));
	}
	else {
		$aparts = explode("/", $path);
		if (count($aparts)>0) array_pop($aparts);
		$rparts = explode("/", $relative);
		$cparts = array_merge($aparts, $rparts);
		foreach($cparts as $i => $part) {
			if($part == '.') {
				$cparts[$i] = null;
			}
			if($part == '..') {
				$cparts[$i - 1] = null;
				$cparts[$i] = null;
			}
		}
		$cparts = abi_array_filter($cparts);
	}

	//##+kenfoo 14042007. Added proper handling of paths ending with a slash.
	//Earlier code dropped the final slash, causing problems with Facebook /inbox/.
	$n = strlen($relative);
	if ($n>0 && $relative[$n-1]=='/') $cparts[]='';


	$path = implode("/", $cparts);
	$url = "";
	if(isset($scheme)) {
		$url = "$scheme://";
	}
	if(isset($user)) {
		$url .= "$user";
		if($pass) {
			$url .= ":$pass";
		}
		$url .= "@";
	}
	if(isset($host)) {
		$url .= $host;
		if(isset($port)) $url .= ":$port";
		$url .='/';
	}
	$url .= $path;
	return $url;
}


class OzHtmlAttribute {
	var $name;
	var $value;
}

class OzHtmlAttributeTokenizer {
	var $html;
	var $i;
	var $n;

	function OzHtmlAttributeTokenizer($html) {
		$this->html = $html;
		$this->i = 0;
		$this->n = strlen($html);
	}

	function skipWhitespace() {
		for (; $this->i < $this->n; $this->i++) {
			$c = $this->html[$this->i];
			// We'll skip '/' character as well (and other invalid
			// characters).
			if ($c==='/' && (($this->i+1>= $this->n || $this->html[$this->i+1]!=='>')))
				continue;
			if ($c != ' ' && $c != "\t" && $c != "\r" && $c != "\n")
				break;
		}
	}

	function extractAttributeElement() {
		$quoteChar = chr(0);
		if ($this->i >= $this->n)
			return null;
		$c = $this->html[$this->i];
		if ($c == "'" || $c == '"') {
			$quoteChar = $c;
			$this->i++;
		}
		$i1 = $this->i;
		for (; $this->i < $this->n; $this->i++) {
			$c = $this->html[$this->i];
			if ($quoteChar == chr(0)) {
				// If it's a '/' character, then ensure the next is '>',
				// otherwise it's just an invalid character
				if ($c == '\'' || $c == '"' || $c == '>' || $c == '=' || $c==' ' || $c=="\t" || $c=="\r" || $c=="\n") {
					break;
				}
			} else {
				if ($c == $quoteChar) {
					$s = substr($this->html,$i1,$this->i-$i1);
					$this->i++;
					return htmlentities2utf8($s);
				}
			}
		}
		if ($i1 == $this->i)
			return NULL;
		else
			return htmlentities2utf8(substr($this->html,$i1,$this->i-$i1));
	}

	function nextAttribute() {

		$name = NULL;
		$value = NULL;

		$this->skipWhitespace();
		$name = $this->extractAttributeElement();
		if ($name == NULL) {
			return NULL;
		}
		$this->skipWhitespace();

		// If next item is a "=" then it's an equals sign
		if ($this->i < $this->n && $this->html[$this->i] == '=') {
			$this->i++;
			$this->skipWhitespace();
			$value = $this->extractAttributeElement();
		}

		$attrib = new OzHtmlAttribute;
		$attrib->name = $name;
		$attrib->value = $value;
		return $attrib;
	}
}

function oz_extract_form_by_name($html, $name) {
	//$name = strtolower($name);
	$res = oz_extract_forms($html);
	foreach ($res as $fo) {
		//$name2 = strtolower($fo->name);
		//if ($name==$name2) return $fo;
		if ($name==$fo->name) return $fo;
	}
	return null;
}

function oz_extract_form_by_id($html, $formId) {
	//$formId = strtolower($formId);
	$res = oz_extract_forms($html);
	foreach ($res as $fo) {
		//$formId2 = strtolower($fo->id);
		//if ($formId==$formId2) return $fo;
		if ($formId==$fo->id) return $fo;
	}
	return null;
}


function oz_extract_forms ($html,$onlyHidden=true) {
	$FORM_REGEX = "/<form([^>]*)>(.*?)<\/form[^>]*>/ims";
	$HIDDEN_FIELDS = "/<input\s*([^>]*type\s*=\s*(?:\"hidden\"|'hidden'|hidden)[^>]*)>/ims";
	$ALL_FIELDS = "/<input\s*([^>]*)>/ims";

	$html = preg_replace("/<!--.*?-->/ms",'',$html);

	preg_match_all($FORM_REGEX, $html, $matches, PREG_SET_ORDER);
	$res = array();
	foreach ($matches as $val) {
		$forminfo = $val[1];
		$formhtml = $val[2];
		$fo = new HttpForm;

		$at = new OzHtmlAttributeTokenizer($forminfo);
		while (true) {
			$a = $at->nextAttribute();
			if ($a == null)
				break;
			$a->name = strtolower($a->name);

			if ("id"==$a->name) $fo->id = $a->value;
			else if ("name"==$a->name) $fo->name = $a->value;
			else if ("action"==$a->name) $fo->action = $a->value;
			else if ("method"==$a->name) $fo->method = $a->value;
			else if ("enctype"==$a->name) $fo->enctype = $a->value;
		}

		preg_match_all($onlyHidden?$HIDDEN_FIELDS:$ALL_FIELDS, $formhtml, $matches3, PREG_SET_ORDER);
		foreach ($matches3 as $val2) {
			$fieldhtml = $val2[1];

			$at = new OzHtmlAttributeTokenizer($fieldhtml);
			$name = NULL;
			$value = "";
			while (true) {
				$a = $at->nextAttribute();
				if ($a == null)
					break;
				$a->name = strtolower($a->name);
				if ("name"==$a->name) $name = $a->value;
				else if ("value"==$a->name) $value = $a->value;
			}
			if (!empty($name)) $fo->addField($name,$value);
		}
		$res[] = $fo;
	}

	return $res;
}

function oz_instanceof(&$obj, $type) {
	if (oz_is_php5()) {
		return eval('return $obj instanceof '.$type.';');
	}
	else {
		return is_a($obj,$type);
	}
}


//-----------------------------------------------------
//Deduplicate contacts.
//
//Parameters:
//	$contacts - Array of Contact objects
//Returns:
//	Deduplicated array of Contact objects
//-----------------------------------------------------
//@api
function abi_dedupe_contacts ($contacts) {
	$res = array();
	$set = array();
	foreach ($contacts as $contact) {
		$key = strtolower($contact->name).'|'.strtolower($contact->email);
		if (!isset($set[$key])) {
			$set[$key] = $key;
			$res[] = $contact;
		}
	}
	return $res;
}

//@api
function abi_dedupe_contacts_by_email ($contacts) {
	$res = array();
	$set = array();
	foreach ($contacts as $contact) {
		$key = strtolower($contact->email);
		if (!isset($set[$key])) {
			$set[$key] = $key;
			$res[] = $contact;
		}
	}
	return $res;
}

//@api
function abi_compare_contacts(&$c1, &$c2)
{
	return strcasecmp($c1->name,$c2->name);
}


//-----------------------------------------------------
//Sort contacts in ascending order
//
//Parameters:
//	$contacts - Array of Contact objects
//Returns:
//	Deduplicated array of Contact objects
//-----------------------------------------------------
//@api
function abi_sort_contacts_by_name ($contacts) {
	//Note that $contacts is pass by value, not reference
	usort($contacts, "abi_compare_contacts");
	return $contacts;
}

//@api
function abi_valid_email($email) {
	//if (!preg_match("/^([+=&'\/\\?\\^\\~a-zA-Z0-9\._-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-]+)+/", $email))
	//	return false;
	if (!preg_match("/^([a-zA-Z0-9\\._!#\\\$\\%&\\'*+\\-\\/=\\?\\^`{|}\\~])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-]+)+/", $email))
		return false;
	return true;

}

//Replacement for PHP's parse_url which chokes on many different forms of urls.
function oz_parse_url ($url) {
	//This function adapted and improved from: parseUrl() in http://my2.php.net/function.parse-url
	$r  = '!(?:(\w+)://)?(?:(\w+)\:(\w+)@)?([^/:?#]+)?';
	$r .= '(?:\:(\d*))?([^#?]+)?(?:\?([^#]+))?(?:#(.+$))?!i';
	if (preg_match ( $r, $url, $out )==0)
		return FALSE;

	$res = array();
	if (!empty($out[1])) $res['scheme'] = $out[1];
	if (!empty($out[2])) $res['user'] = $out[2];
	if (!empty($out[3])) $res['pass'] = $out[3];
	if (!empty($out[4])) $res['host'] = $out[4];
	if (!empty($out[5])) $res['port'] = $out[5];
	if (!empty($out[6])) $res['path'] = $out[6];
	if (!empty($out[7])) $res['query'] = $out[7];
	if (!empty($out[8])) $res['fragment'] = $out[8];

	return $res;

}


function oz_get_refresh_url($html) {
	$REDIRECT_REGEX = "/(<meta[^>]*http-equiv\\s*=\\s*[\"']?refresh[\"'>]?[^>]*>)/ims";
	if (preg_match($REDIRECT_REGEX,$html,$matches)==0) return null;
	$html = $matches[1];
	$METAREFRESH_REGEX = "/url\\s*=\\s*([^\"'>]*)/ims";
	if (preg_match($METAREFRESH_REGEX,$html,$matches)==0) return '';
	$html = htmlentities2utf8(trim($matches[1]));
	$n = strlen($html);
	if ($n>0) {
		$c = $html[0];
		if ($c=='\'' || $c=='"') {
			if ($c==$html[$n-1]) $html=substr($html,1,$n-2);
			else $html=substr($html,1);
		}
	}
	return $html;
}

function oz_extract_params($url) {
	$map = array();
	$i = strpos($url,'?');
	if ($i!==FALSE) $url = substr($url,$i+1);
	$parts = explode('&',$url);
	foreach ($parts as $part) {
		$va = explode('=',$part,2);
		if (count($va)==2) {
			$key = urldecode($va[0]);
			$value = urldecode($va[1]);
			$map[$key]=$value;
		}
	}
	return $map;
}

function oz_extract_param($url,$param,$defaultVal=NULL) {
	$map = oz_extract_params($url);
	return isset($map[$param])?$map[$param]:$defaultVal;
}



//@api
function oz_get_supported_services($type=NULL)
{
	global $_OZ_SERVICES;
	if ($type==NULL) return $_OZ_SERVICES;
	$al = array();
	foreach ($_OZ_SERVICES as $key=>$info)
		if ($info['type']==$type)
			$al[$key] = $info;
	ksort($al);
	return $al;
}

//@api
function oz_is_service_supported($id)
{
	global $_OZ_SERVICES;
	return empty($id) || isset($_OZ_SERVICES[$id]);
}


//@api
function oz_get_service_info($svcid) {
	global $_OZ_SERVICES;
	if (isset($_OZ_SERVICES[$svcid])) return $_OZ_SERVICES[$svcid];
	else return NULL;
}

//@api
function oz_get_supported_domains()
{
	global $_DOMAIN_IMPORTERS;
	//Ignore domains without "." inside it( eg. gmail is ignored. gmail.com is taken)
	$al = array();
	foreach ($_DOMAIN_IMPORTERS as $domain=>$classname) {
		if (strpos($domain,'.')!==FALSE) $al[]=$domain;
		//Do we also need to test if the class exists?
	}
	sort($al);
	return $al;
}


function abi_email_as_name() {
	return oz_get_config('email_as_name',TRUE);
}



//Convert an array into PHP source code form
//
//Negative indent value to have no formatting/indentation

//@api
function oz_array_to_php(&$arr,$indent=0) {
	$s= 'array(';
	if ($indent>=0) $s.="\r\n";
	$is_assoc = array_values($arr)!==$arr;
	$first = true;
	foreach ($arr as $k=>$v) {
		if ($indent>=0) {
			if (!$first) $s.=",\r\n";
			$s.=str_repeat(' ',$indent+1);
		}
		elseif (!$first) $s.=',';
		if ($is_assoc) $s.='\''.$k.'\'=>';
		if ($v===NULL) $s.='NULL';
		else if ($v===TRUE) $s.='TRUE';
		else if ($v===FALSE) $s.='FALSE';
		else if (is_array($v)) $s.=to_phparray($v,$indent>=0?$indent+1:$indent);
		else if (is_string($v)) {
			$n = strlen($v);
			$s2='"';
			for ($i=0;$i<$n;$i++) {
				$c = $v[$i];
				$o = ord($c);
				if ($o===13) $s2.='\\r';
				else if ($o===10) $s2.='\\n';
				else if ($o===9) $s2.='\\t';
				else if ($o===34) $s2.='\\"';
				else if ($o===36) $s2.='\\$';
				else if ($o===92) $s2.='\\\\';
				else if ($o<32 || $o>126) {$s2.=$o<16?'\\x0':'\\x';$s2.=dechex($o);}
				else $s2.=$c;
			}
			$s.=$s2.'"';
		}
		else $s.=$v;
		$first=false;
	}
	if ($indent>=0) $s.="\r\n".str_repeat(' ',$indent);
	$s.=")";
	return $s;
}


global $_OZ_LAST_DOMAIN;

function oz_set_domain($domain) {
	global $_OZ_LAST_DOMAIN;
	$_OZ_LAST_DOMAIN = $domain;
}


//Return email in array of id, domain
function oz_get_email_parts ($email) {
	if (preg_match("/([^@]*)@(.*)/ims",$email,$matches)==0) {
		return array(trim($email),"");
	}
	else {
		$res = array();
		$res[0] = strtolower(trim($matches[1]));
		$res[1] = strtolower(trim($matches[2]));
		return $res;
	}
}

function oz_get_email_domain ($email) {
	$parts = oz_get_email_parts($email);
	return $parts[1];
}

function oz_convert_charset ($str, $from, $to) {
 
 	if ($from==$to) return $str;

	//Convert character set to utf-8
	if (function_exists('mb_convert_encoding')) return mb_convert_encoding($str, $to, $from);
	else if (function_exists('iconf')) return iconv($from, $to, $str);
}